<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Mouse Cursors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script>
      let msg = NaN
      let msgperseccounter = 0
      let dropped = false
      let droppedDuration = 0
      let droppedCollection = []
      let maxDrop = 0
      let img
      let mouseCursors = {} // Object to store mouse cursor positions by device ID
      // Load the image.
      function preload() {
        img = loadImage("/cursor.png")
      }

      setInterval(function () {
        // console.log("messages per second ", msgperseccounter)
        msg = msgperseccounter
        msgperseccounter = 0
      }, 1000)

      setInterval(function () {
        // check if you have gotten a new message. if so,
        if (dropped) {
          droppedDuration++
        } else {
          droppedCollection.push(droppedDuration)
          droppedDuration = 0
          dropped = true
          maxDrop = Math.max(...droppedCollection)
        }
        // add number to highscore array and
        // reset counter.
        // if not, add 1 to counter
        // always display biggest number
      }, 1)

      function setup() {
        // Load the image.
        createCanvas(windowWidth, windowHeight)
        noStroke()
        let button = createButton("reset maxDrop")
        button.position(300, 50)

        // Call repaint() when the button is pressed.
        button.mousePressed(function () {
          droppedCollection = []
          maxDrop = 0
        })

        // Connect to the WebSocket server
        const ws = new WebSocket("ws://localhost:8080")

        ws.onopen = () => {
          console.log("Connected to WebSocket server")
        }

        ws.onmessage = (event) => {
          dropped = false
          msgperseccounter++
          // Parse the incoming JSON data
          const data = JSON.parse(event.data)
          // data.timestamp_CLIENT = Date.now()
          // console.log(data)

          if (data.length > 0) {
            data.forEach((instruction, index) => {
              instruction.timestamp_client = Date.now()
              // console.log("timestamps =", instruction.timestamp_rasp, instruction.timestamp_client)
              // console.log("supposed latency =", instruction.timestamp_client - instruction.timestamp_rasp)
              const supposedLatency = instruction.timestamp_client - instruction.timestamp_rasp
              // check if he is logged in the posxy array
              // if hes not initialise le
              // if he is, just add the acceleration to the pos

              if (!(instruction.client in mouseCursors)) {
                // hmmmm we want to order the rasps using their id number
                const regex = /th(\d{0,})/
                thIndex = regex.exec(instruction.client)[1]
                mouseCursors[instruction.client] = { coords: { x: 2000, y: index * 40 + 200 }, latency: [supposedLatency] }
                // for logging purposes, it's nice to know which cursor is which rasp oh yeah
                // let's use regex to decompose the client name "th1_mouse-HP-thingy"
                // rather than sending a proper objet in the first place (sounds smart)
                mouseCursors[instruction.client].rasp = instruction.client.match("(.+)_(.+)")[1]
                mouseCursors[instruction.client].device = instruction.client.match("(.+)_(.+)")[2]
              } else {
                mouseCursors[instruction.client].coords.x = mouseCursors[instruction.client].coords.x + instruction.x
                mouseCursors[instruction.client].coords.y = mouseCursors[instruction.client].coords.y + instruction.y
                mouseCursors[instruction.client].latency.push(supposedLatency)
              }
            })
          }
        }

        ws.onerror = (error) => {
          console.error("WebSocket error:", error)
        }

        ws.onclose = () => {
          console.log("WebSocket connection closed")
        }
      }

      function draw() {
        background(255)
        fill(0, 0, 0)
        text("the following THs are connected to 2,4GHz : 2, 6, 7, 10, 11. The follwing TH is connected to ETH : 11", 10, 10, 150, 200)

        text("messages recieved " + msg + "/s", 200, 10, 100, 100)
        text("max drop between server & client" + maxDrop, 300, 10, 200, 200)

        // Draw each cursor on the canvas
        for (let client in mouseCursors) {
          const cursor = mouseCursors[client]
          image(img, cursor.coords.x / 3, cursor.coords.y / 3, 32, 50)

          // Calculate the maximum latency for the client
          let maxLatency = Math.max(...cursor.latency)

          // Set text color based on latency threshold
          if (maxLatency > 100) {
            fill(255, 0, 0) // Red for latency > 100ms
          } else {
            fill(0, 255, 0) // Black for latency <= 100ms
          }

          text(mouseCursors[client].rasp + ", lat " + maxLatency + "ms", cursor.coords.x / 3 + 20, cursor.coords.y / 3 - 15, 100, 25)
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight)
      }

      // class LatencyCalculator {
      //   constructor() {
      //     this.totalLatency = 0
      //     this.maxLatency = 0
      //     this.count = 0
      //   }

      //   /**
      //    * Processes an incoming data object with `timestamp_rasp` and `timestamp_client`.
      //    * Updates mean latency and maximum latency (jitter).
      //    * @param {Object} data - An object containing `timestamp_rasp` and `timestamp_client`.
      //    */
      //   processData(data) {
      //     if (!data.timestamp_rasp || !data.timestamp_client) {
      //       throw new Error("Data object must contain timestamp_rasp and timestamp_client")
      //     }

      //     const latency = data.timestamp_rasp - data.timestamp_client

      //     // Update statistics
      //     this.totalLatency += latency
      //     this.count++
      //     if (latency > this.maxLatency) {
      //       this.maxLatency = latency
      //     }
      //   }

      //   /**
      //    * Returns the mean latency.
      //    * @returns {number} - Mean latency in milliseconds.
      //    */
      //   getMeanLatency() {
      //     return this.count > 0 ? this.totalLatency / this.count : 0
      //   }

      //   /**
      //    * Returns the maximum latency (jitter).
      //    * @returns {number} - Maximum latency in milliseconds.
      //    */
      //   getMaxLatency() {
      //     return this.maxLatency
      //   }
      // }
    </script>
  </body>
</html>
