<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Mouse Cursors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script>
      let msg = NaN
      let msgperseccounter = 0
      let dropped = false
      let droppedDuration = 0
      let droppedCollection = []
      let maxDrop = 0
      let img
      let mouseCursors = {} // Object to store mouse cursor positions by device ID
      // Load the image.
      function preload() {
        img = loadImage("/cursor.png")
      }

      setInterval(function () {
        // console.log("messages per second ", msgperseccounter)
        msg = msgperseccounter
        msgperseccounter = 0
      }, 1000)

      setInterval(function () {
        // check if you have gotten a new message. if so,
        if (dropped) {
          droppedDuration++
        } else {
          droppedCollection.push(droppedDuration)
          droppedDuration = 0
          dropped = true
          maxDrop = Math.max(...droppedCollection)
        }
        // add number to highscore array and
        // reset counter.
        // if not, add 1 to counter
        // always display biggest number
      }, 1)

      function setup() {
        // Load the image.
        createCanvas(windowWidth, windowHeight)
        noStroke()
        let button = createButton("reset maxDrop")
        button.position(300, 50)

        // Call repaint() when the button is pressed.
        button.mousePressed(function () {
          droppedCollection = []
          maxDrop = 0
        })

        // Connect to the WebSocket server
        const ws = new WebSocket("ws://localhost:8080")

        ws.onopen = () => {
          console.log("Connected to WebSocket server")
        }

        ws.onmessage = (event) => {
          dropped = false
          msgperseccounter++
          // Parse the incoming JSON data
          const data = JSON.parse(event.data)
          // data.timestamp_CLIENT = Date.now()
          // console.log(data)

          if (data.length > 0) {
            data.forEach((instruction) => {
              // check if he is logged in the posxy array
              // if hes not initialise le
              // if he is, just add the acceleration to the pos
              // console.log(instruction.client)
              if (!(instruction.client in mouseCursors)) {
                mouseCursors[instruction.client] = { coords: { x: 1000, y: 1000 } }
              } else {
                mouseCursors[instruction.client].coords.x = mouseCursors[instruction.client].coords.x + instruction.x
                mouseCursors[instruction.client].coords.y = mouseCursors[instruction.client].coords.y + instruction.y
              }
            })
          }

          // // est ce qu'on a déjà une mémoire pour ce device?
          // if (id != "undefined_undefined" || id == undefined) {
          //   if (!(id in mouseCursors)) {
          //     // si non, initialise le
          //     mouseCursors[id] = { coords: { x: 1000, y: 1000 } }
          //   }

          // // latency between rasp & serv DOES NOT WORK! we're getting negative numbers... wtf

          // console.log("R", data.timestamp_RASP, " S", data.timestamp_SERVER)
          // const raspServLag = data.timestamp_SERVER - data.timestamp_RASP
          // // console.log("raspLag ", raspServLag)
          // const servClientLag = data.timestamp_CLIENT - data.timestamp_SERVER
          // const totalLatency = raspServLag + servClientLag
          // // console.log(totalLatency)
          // // latency between serv & client
          // mouseCursors[id].latency = totalLatency
          // }

          // on ajoute a un tableau qui sera vidé à 60Hz

          // switch (data.code) {
          //   case "REL_X":
          //     mouseCursors[id].coords.x = mouseCursors[id].coords.x + data.value
          //     break
          //   case "REL_Y":
          //     mouseCursors[id].coords.y = mouseCursors[id].coords.y + data.value
          //     break

          //   default:
          //     // console.log("unknown event code")
          //     break
          // }
        }

        ws.onerror = (error) => {
          console.error("WebSocket error:", error)
        }

        ws.onclose = () => {
          console.log("WebSocket connection closed")
        }
      }

      function draw() {
        background(255)
        // text("la latence est exprimée en milisecondes entre le moment où l'evenement est simulé côté rasp et le moment où il est reçu côté client JS. La majorité de la latence est entre les rasp & le serveur.", 10, 10, 200, 200)

        text("messages recieved " + msg + "/s", 200, 10, 100, 100)
        text("max drop " + maxDrop, 300, 10, 200, 200)

        // Draw each cursor on the canvas
        for (let client in mouseCursors) {
          const cursor = mouseCursors[client]
          fill(0, 0, 0, 150) // Set color for the cursor (blue with transparency)
          image(img, cursor.coords.x / 3, cursor.coords.y / 3, 32, 50)
          // text(mouseCursors[id].latency + " ms", mouseCursors[id].coords.x / 3, mouseCursors[id].coords.y / 3)
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight)
      }
    </script>
  </body>
</html>
