<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dynamic Mouse Cursors</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <script>
      let msg = NaN
      let msgperseccounter = 0
      let dropped = false
      let droppedDuration = 0
      let droppedCollection = []
      let maxDrop = 0
      let img
      let mouseCursors = {} // Object to store mouse cursor positions by device ID
      // Load the image.
      function preload() {
        img = loadImage("/cursor.png")
      }

      setInterval(function () {
        // console.log("messages per second ", msgperseccounter)
        msg = msgperseccounter
        msgperseccounter = 0
      }, 1000)

      setInterval(function () {
        // check if you have gotten a new message. if so,
        if (dropped) {
          droppedDuration++
        } else {
          droppedCollection.push(droppedDuration)
          droppedDuration = 0
          dropped = true
          maxDrop = Math.max(...droppedCollection)
        }
        // add number to highscore array and
        // reset counter.
        // if not, add 1 to counter
        // always display biggest number
      }, 1)

      function setup() {
        // Load the image.
        createCanvas(windowWidth, windowHeight)
        noStroke()
        let button = createButton("reset maxDrop")
        button.position(300, 50)

        // Call repaint() when the button is pressed.
        button.mousePressed(function () {
          droppedCollection = []
          maxDrop = 0
        })

        // Connect to the WebSocket server
        const ws = new WebSocket("ws://localhost:8080")

        ws.onopen = () => {
          console.log("Connected to WebSocket server")
        }

        ws.onmessage = (event) => {
          dropped = false
          msgperseccounter++
          // Parse the incoming JSON data
          const data = JSON.parse(event.data)
          // data.timestamp_CLIENT = Date.now()
          // console.log(data)

          if (data.length > 0) {
            data.forEach((instruction) => {
              instruction.timestamp_client = Date.now()
              // console.log("timestamps =", instruction.timestamp_rasp, instruction.timestamp_client)
              // console.log("supposed latency =", instruction.timestamp_client - instruction.timestamp_rasp)
              const supposedLatency = instruction.timestamp_client - instruction.timestamp_rasp
              // check if he is logged in the posxy array
              // if hes not initialise le
              // if he is, just add the acceleration to the pos
              // console.log(instruction.client)
              if (!(instruction.client in mouseCursors)) {
                mouseCursors[instruction.client] = { coords: { x: 1000, y: 1000 }, latency: [supposedLatency] }
              } else {
                mouseCursors[instruction.client].coords.x = mouseCursors[instruction.client].coords.x + instruction.x
                mouseCursors[instruction.client].coords.y = mouseCursors[instruction.client].coords.y + instruction.y
                mouseCursors[instruction.client].latency.push(supposedLatency)
              }
            })
          }
        }

        ws.onerror = (error) => {
          console.error("WebSocket error:", error)
        }

        ws.onclose = () => {
          console.log("WebSocket connection closed")
        }
      }

      function draw() {
        background(255)
        text("la latence est exprimée en milisecondes entre le moment où l'evenement est simulé côté rasp et le moment où il est reçu côté client JS. La majorité de la latence est entre les rasp & le serveur.", 10, 10, 200, 200)

        text("messages recieved " + msg + "/s", 200, 10, 100, 100)
        text("max drop between server & client" + maxDrop, 300, 10, 200, 200)

        // Draw each cursor on the canvas
        for (let client in mouseCursors) {
          const cursor = mouseCursors[client]
          fill(0, 0, 0, 150) // Set color for the cursor (blue with transparency)
          image(img, cursor.coords.x / 3, cursor.coords.y / 3, 32, 50)
          // text(mouseCursors[id].latency + " ms", mouseCursors[id].coords.x / 3, mouseCursors[id].coords.y / 3)
          text(Math.max(...mouseCursors[client].latency) + "ms", cursor.coords.x / 3 + 20, cursor.coords.y / 3, 25, 25)
        }
      }

      function windowResized() {
        resizeCanvas(windowWidth, windowHeight)
      }

      // class LatencyCalculator {
      //   constructor() {
      //     this.totalLatency = 0
      //     this.maxLatency = 0
      //     this.count = 0
      //   }

      //   /**
      //    * Processes an incoming data object with `timestamp_rasp` and `timestamp_client`.
      //    * Updates mean latency and maximum latency (jitter).
      //    * @param {Object} data - An object containing `timestamp_rasp` and `timestamp_client`.
      //    */
      //   processData(data) {
      //     if (!data.timestamp_rasp || !data.timestamp_client) {
      //       throw new Error("Data object must contain timestamp_rasp and timestamp_client")
      //     }

      //     const latency = data.timestamp_rasp - data.timestamp_client

      //     // Update statistics
      //     this.totalLatency += latency
      //     this.count++
      //     if (latency > this.maxLatency) {
      //       this.maxLatency = latency
      //     }
      //   }

      //   /**
      //    * Returns the mean latency.
      //    * @returns {number} - Mean latency in milliseconds.
      //    */
      //   getMeanLatency() {
      //     return this.count > 0 ? this.totalLatency / this.count : 0
      //   }

      //   /**
      //    * Returns the maximum latency (jitter).
      //    * @returns {number} - Maximum latency in milliseconds.
      //    */
      //   getMaxLatency() {
      //     return this.maxLatency
      //   }
      // }
    </script>
  </body>
</html>
